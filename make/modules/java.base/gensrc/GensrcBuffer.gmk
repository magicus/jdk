#
# Copyright (c) 2011, 2025, Oracle and/or its affiliates. All rights reserved.
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
#
# This code is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 2 only, as
# published by the Free Software Foundation.  Oracle designates this
# particular file as subject to the "Classpath" exception as provided
# by Oracle in the LICENSE file that accompanied this code.
#
# This code is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# version 2 for more details (a copy is included in the LICENSE file that
# accompanied this code).
#
# You should have received a copy of the GNU General Public License version
# 2 along with this work; if not, write to the Free Software Foundation,
# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
# or visit www.oracle.com if you need additional information or have any
# questions.
#

include MakeIncludeStart.gmk
ifeq ($(INCLUDE), true)

################################################################################

BUFFER_INPUT_DIR := $(MODULE_SRC)/share/classes/java/nio
BUFFER_OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)/gensrc/java.base/java/nio

################################################################################

NON_BYTE_TYPES := char short int long float double
TYPES := byte $(NON_BYTE_TYPES)

################################################################################
# The Conv function converts a type given as first argument (as a normal Java
# native type name), into one of several corresponding strings, depending on
# the aspect given in the second argument
#
# The implementation dispatches the call to one of several Conv_<aspect> macros.
#
# arg $1: the type to convert
# arg $2: the aspect to convert for
# arg $3: byte order (only needed for certain aspects)
#
Conv = \
  $(strip $(call Conv_$(strip $2),$(strip $1)))

################################################################################
# Conv_<aspect> implementations

# Return a single letter representing the type (lowercase first letter)
Conv_x = \
  $(call firstchar, $1)

# Return capitalized type name
Conv_Type = \
  $(call titlecase, $1)

# Return the full descriptive name of the type, e.g. int -> integer
Conv_fulltype = \
  $(if $(filter char, $1), \
    character, \
    $(if $(filter int, $1), \
      integer, \
      $1 \
    ) \
  )

# Return the capitalized full descriptive name of the type, e.g. int -> Integer
Conv_Fulltype = \
  $(call titlecase, $(call Conv_fulltype, $1))

# Return log2 bits per value (0-3)
Conv_LBPV = \
  $(if $(filter byte, $1), \
    0, \
    $(if $(filter char short, $1), \
      1, \
      $(if $(filter int float, $1), \
        2, \
        $(if $(filter long double, $1), \
          3))))

# Return float or int category
Conv_category = \
    $(if $(filter float double, $1), \
      floatingPointType, \
      integralType \
    )

# Return stream information for char
Conv_streams = \
  $(if $(filter char, $1), streamableType)

# Return stream type information for char
Conv_streamtype = \
  $(if $(filter char, $1), int)

# Return capitalized stream type information for char
Conv_Streamtype = \
  $(if $(filter char, $1), Int)

# Return article to use for type in English text
Conv_a = \
  $(if $(filter int, $1), an, a)

# Return capitalized article to use for type in English text
Conv_A = \
  $(if $(filter int, $1), An, A)

# Return integer type with same size as the type
Conv_memtype = \
  $(if $(filter float, $1), int, $(if $(filter double, $1), long, $1))

# Return capitalized integer type with same size as the type
Conv_Memtype = \
  $(call titlecase, $(call Conv, $1, memtype))

# Return Type or Memtype depending on byte order
# arg $2: BYTE_ORDER
Conv_Swaptype = \
  $(if $(filter U, $2), \
      $(call Conv, $1, Type), \
      $(call Conv, $1, Memtype))

# Return fromBits method name for floating types, depending on byte order
# arg $2: BYTE_ORDER
Conv_fromBits = \
  $(if $(filter float double, $1), \
    $(if $(filter U, $2), , \
      $(call Conv, $1, Type).$(call Conv, $1, memtype)BitsTo$(call Conv, $1, Type)))

# Return toBits method name for floating types, depending on byte order
# arg $2: BYTE_ORDER
Conv_toBits = \
  $(if $(filter float double, $1), \
    $(if $(filter U, $2), , \
      $(call Conv, $1, Type).$1ToRaw$(call Conv, $(call Conv, $1, memtype), Type)Bits))

# Return swap method name, depending on byte order
# arg $2: BYTE_ORDER
Conv_swap = \
  $(if $(filter S, $2), Bits.swap)

# Return word describing the number of bytes required by type
Conv_nbytes = \
  $(if $(filter 0, $(call Conv, $1, LBPV)), one, \
    $(if $(filter 1, $(call Conv, $1, LBPV)), two, \
      $(if $(filter 2, $(call Conv, $1, LBPV)), four, \
        $(if $(filter 3, $(call Conv, $1, LBPV)), eight))))

# Return word describing the number of bytes required by type, minus one
Conv_nbytesButOne = \
  $(if $(filter 0, $(call Conv, $1, LBPV)), zero, \
    $(if $(filter 1, $(call Conv, $1, LBPV)), one, \
      $(if $(filter 2, $(call Conv, $1, LBPV)), three, \
        $(if $(filter 3, $(call Conv, $1, LBPV)), seven))))

################################################################################
# Helper method to setup generation of bin snippets.
# Will add the generated snippet file name to $1_BIN_SNIPPET_FILES.
#
# arg $1: $1 as passed into SetupGenBuffer
# arg $2: type for this bin snippet
define SetupGenBufferBinSnippets
  $1_$2_TMP := $$(BUFFER_OUTPUT_DIR)/$1.java.bin-snippet.$2

  $1_$2_LBPV :=  $$(call Conv, $2, LBPV)

  $$(eval $$(call SetupStreamPreProcessing, GEN_BUFFER_BIN_$1_$2, \
      SOURCE_FILE := $$(BUFFER_INPUT_DIR)/$$($1_TEMPLATE)-bin.java.template, \
      OUTPUT_FILE := $$($1_$2_TMP), \
      INFO := Generating buffer class bin snippets for $1 ($2), \
      BEGIN_END := true, \
      KEYS := \
          $$(if $$(filter true, $$($1_READ_ONLY)), ro, rw) \
      REPLACEMENTS := \
          type=$2 \
          RW=$$(strip $$(if $$(filter true, $$($1_READ_ONLY)), R)) \
          LG_BYTES_PER_VALUE=$$($1_$2_LBPV) \
          BYTES_PER_VALUE="(1 << $$($1_$2_LBPV))" \
          a=$$(call Conv, $2, a) \
          fulltype=$$(call Conv, $2, fulltype) \
          memtype=$$(call Conv, $2, memtype) \
          Memtype=$$(call Conv, $2, Memtype) \
          nbytes=$$(call Conv, $2, nbytes) \
          nbytesButOne=$$(call Conv, $2, nbytesButOne) \
          Type=$$(call Conv, $2, Type) \
          fromBits=$$(call Conv, $2, fromBits, $$($1_BYTE_ORDER)) \
          toBits=$$(call Conv, $2, toBits, $$($1_BYTE_ORDER)), \
  ))
  TARGETS += $$(GEN_BUFFER_$1_$2)

  $1_BIN_SNIPPET_FILES += $$($1_$2_TMP)
endef

################################################################################
# Setup make rules that creates a generated buffer class java source file,
# according to specifications provided.
#
# Parameter 1 is the name of the rule. This name is used as variable prefix,
# and the targets generated are listed in a variable by that name. The output
# file name is also based on this.
#
# Remaining parameters are named arguments. These include:
#   TYPE          The native type
#   TEMPLATE      The base file name of the template to use
#   BYTE_ORDER    (U)nswapped/(S)wapped/(L)ittle/(B)ig
#   READ_ONLY     Set to true to generate read-only buffers (default: false)
#   GENERATE_BIN  Set to true to generate bin snippets (default: false)
#
SetupGenBuffer = $(NamedParamsMacroTemplate)
define SetupGenBufferBody
  $1_OUTPUT := $$(BUFFER_OUTPUT_DIR)/$1.java
  ifeq ($$($1_GENERATE_BIN), true)
    # After generating the buffer class, we need to do further post processing,
    # so output to a temporary file
    $1_REAL_OUTPUT := $$($1_OUTPUT)
    $1_OUTPUT := $$($1_OUTPUT).bin-snippet.tmp
  endif

  $1_LBPV := $$(call Conv, $$($1_TYPE), LBPV)

  $$(eval $$(call SetupStreamPreProcessing, GEN_BUFFER_$1, \
      SOURCE_FILE := $$(BUFFER_INPUT_DIR)/$$($1_TEMPLATE).java.template, \
      OUTPUT_FILE := $$($1_OUTPUT), \
      INFO := Generating buffer class $1.java, \
      KEYS := \
          $$($1_TYPE) \
          $$(if $$(filter true, $$($1_READ_ONLY)), ro, rw) \
          bo$$($1_BYTE_ORDER) \
          $$(call Conv, $$($1_TYPE), category) \
          $$(call Conv, $$($1_TYPE), streams), \
      REPLACEMENTS := \
          type=$$($1_TYPE) \
          BO=$$($1_BYTE_ORDER) \
          RW=$$(strip $$(if $$(filter true, $$($1_READ_ONLY)), R)) \
          LG_BYTES_PER_VALUE=$$($1_LBPV) \
          BYTES_PER_VALUE="(1 << $$($1_LBPV))" \
          a=$$(call Conv, $$($1_TYPE), a) \
          A=$$(call Conv, $$($1_TYPE), A) \
          fulltype=$$(call Conv, $$($1_TYPE), fulltype) \
          Fulltype=$$(call Conv, $$($1_TYPE), Fulltype) \
          memtype=$$(call Conv, $$($1_TYPE), memtype) \
          Memtype=$$(call Conv, $$($1_TYPE), Memtype) \
          streamtype=$$(call Conv, $$($1_TYPE), streamtype) \
          Streamtype=$$(call Conv, $$($1_TYPE), Streamtype) \
          Type=$$(call Conv, $$($1_TYPE), Type) \
          x=$$(call Conv, $$($1_TYPE), x) \
          fromBits=$$(call Conv, $$($1_TYPE), fromBits, $$($1_BYTE_ORDER)) \
          toBits=$$(call Conv, $$($1_TYPE), toBits, $$($1_BYTE_ORDER)) \
          swap=$$(call Conv, $$($1_TYPE), swap, $$($1_BYTE_ORDER)) \
          Swaptype=$$(call Conv, $$($1_TYPE), Swaptype, $$($1_BYTE_ORDER)), \
  ))
  TARGETS += $$(GEN_BUFFER_$1)

  ifeq ($$($1_GENERATE_BIN), true)
    # Setup generation of snippet files, one for each non-byte type. This will
    # populate $1_BIN_SNIPPET_FILES.
    $1_BIN_SNIPPET_FILES :=
    $$(foreach t, $$(NON_BYTE_TYPES), \
      $$(eval $$(call SetupGenBufferBinSnippets,$1,$t)) \
    )

    # Inject these snippets in the file generated by GEN_BUFFER_$1
    $$($1_REAL_OUTPUT): $$($1_OUTPUT) $$($1_BIN_SNIPPET_FILES)
	$$(call LogInfo, Concatenating buffer class bin snippets for $1)
        # Delete everything from the line containing #BIN and below
	$$(SED) -e '/#BIN/,$$$$d' < $$($1_OUTPUT) > $$($1_REAL_OUTPUT).tmp
	$$(CAT) $$($1_BIN_SNIPPET_FILES) >> $$($1_REAL_OUTPUT).tmp
	$$(ECHO) "}" >> $$($1_REAL_OUTPUT).tmp
	$$(MV) $$($1_REAL_OUTPUT).tmp $$($1_REAL_OUTPUT)

    TARGETS += $$($1_REAL_OUTPUT)
  endif
endef

################################################################################
# Helper method to setup generation of all buffer classes, for a given
# modifiability state (read-only or not)
#
# arg $1: READ_ONLY argument, true or false
# arg $2: Modifiability marker for class name (R or empty)
define SetupGenerateBuffersWithRO
  ifeq ($1, false)
    # The basic buffer classes are not generated in READ_ONLY versions
    $$(eval $$(call SetupGenBuffer, ByteBuffer, \
        TYPE := byte, \
        TEMPLATE := X-Buffer, \
        GENERATE_BIN := true, \
    ))
    TARGETS += $$(ByteBuffer)

    $$(foreach t, $$(NON_BYTE_TYPES), \
      $$(eval $$(call SetupGenBuffer, $$(call capitalize, $$t)Buffer, \
          TYPE := $$t, \
          TEMPLATE := X-Buffer, \
      )) \
      $$(eval TARGETS += $$(call capitalize, $$t)Buffer) \
    )
  endif

  # Buffers whose contents are heap-allocated, one for every type
  $$(foreach t, $$(TYPES), \
    $$(eval $$(call SetupGenBuffer, Heap$$(call capitalize, $$t)Buffer$2, \
        TYPE := $$t, \
        TEMPLATE := Heap-X-Buffer, \
        READ_ONLY := $1, \
    )) \
    $$(eval TARGETS += Heap$$(call capitalize, $$t)Buffer$2) \
  )

  # Treat byte special for DirectByteBuffer classes
  $$(eval $$(call SetupGenBuffer, DirectByteBuffer$2, \
      TEMPLATE := Direct-X-Buffer, \
      TYPE := byte, \
      GENERATE_BIN := true, \
      READ_ONLY := $1, \
  ))
  TARGETS += DirectByteBuffer$2

  # Generate Unswapped, Swapped, Big and Little endian views of the direct byte
  # buffers, each for every non-byte type
  $$(foreach b, U S B L, \
    $$(foreach t, $$(NON_BYTE_TYPES), \
      $$(eval $$(call SetupGenBuffer, Direct$$(call capitalize, $$t)Buffer$2$b, \
          TYPE := $$t, \
          TEMPLATE := Direct-X-Buffer, \
          BYTE_ORDER := $b, \
          READ_ONLY := $1, \
      )) \
      $$(eval TARGETS += Direct$$(call capitalize, $$t)Buffer$2$b) \
    ) \
  )
endef

################################################################################
# Generate buffers in both read-write and read-only variants for all buffers

$(eval $(call SetupGenerateBuffersWithRO,false,))
$(eval $(call SetupGenerateBuffersWithRO,true,R))

################################################################################

endif # include guard
include MakeIncludeEnd.gmk
