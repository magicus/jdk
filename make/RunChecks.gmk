#
# Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
#
# This code is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 2 only, as
# published by the Free Software Foundation.  Oracle designates this
# particular file as subject to the "Classpath" exception as provided
# by Oracle in the LICENSE file that accompanied this code.
#
# This code is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# version 2 for more details (a copy is included in the LICENSE file that
# accompanied this code).
#
# You should have received a copy of the GNU General Public License version
# 2 along with this work; if not, write to the Free Software Foundation,
# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
# or visit www.oracle.com if you need additional information or have any
# questions.
#

default: all

include $(SPEC)
include MakeBase.gmk
include FindChecks.gmk

# We will always run multiple checks serially
.NOTPARALLEL:

################################################################################
# Parse global control variables
################################################################################

ifneq ($(CHECK_VM_OPTS), )
  ifneq ($(CHECK_OPTS), )
    CHECK_OPTS := $(CHECK_OPTS);VM_OPTIONS=$(CHECK_VM_OPTS)
  else
    CHECK_OPTS := VM_OPTIONS=$(CHECK_VM_OPTS)
  endif
endif

$(eval $(call ParseKeywordVariable, CHECK_OPTS, \
    SINGLE_KEYWORDS := JOBS TIMEOUT_FACTOR JCOV JCOV_DIFF_CHANGESET, \
    STRING_KEYWORDS := VM_OPTIONS JAVA_OPTIONS, \
))

# Helper function to propagate CHECK_OPTS values.
#
# Note: No spaces are allowed around the arguments.
# Arg $1 The variable in CHECK_OPTS to propagate
# Arg $2 The control variable to propagate it to
define SetCheckOpt
  ifneq ($$(CHECK_OPTS_$1), )
    $2_$1 := $$(CHECK_OPTS_$1)
  endif
endef


################################################################################
# Hook to include the corresponding custom file, if present.
$(eval $(call IncludeCustomExtension, RunChecks.gmk))
################################################################################

# This is the JDK that we will check
JDK_UNDER_CHECK := $(JDK_IMAGE_DIR)

CHECK_RESULTS_DIR := $(OUTPUTDIR)/check-results
CHECK_SUPPORT_DIR := $(OUTPUTDIR)/check-support
CHECK_SUMMARY := $(CHECK_RESULTS_DIR)/check-summary.txt
CHECK_LAST_IDS := $(CHECK_SUPPORT_DIR)/check-last-ids.txt

################################################################################
# Setup global check running parameters
################################################################################

# Each factor variable comes in 3 variants. The first one is reserved for users
# to use on command line. The other two are for predefined configurations in JDL
# and for machine specific configurations respectively.
CHECK_JOBS_FACTOR ?= 1
CHECK_JOBS_FACTOR_JDL ?= 1
CHECK_JOBS_FACTOR_MACHINE ?= 1

ifeq ($(CHECK_JOBS), 0)
  CORES_DIVIDER := 2
  # For some big multi-core machines with low ulimit -u setting we hit the max
  # threads/process limit. In such a setup the memory/cores-only-guided
  # CHECK_JOBS config is insufficient. From experience a concurrency setting of
  # 14 works reasonably well for low ulimit values (<= 4096). Thus, use
  # divider 4096/14. For high ulimit -u values this shouldn't make a difference.
  ULIMIT_DIVIDER := (4096/14)
  PROC_ULIMIT := -1
  ifneq ($(OPENJDK_TARGET_OS), windows)
    PROC_ULIMIT := $(shell $(ULIMIT) -u)
    ifeq ($(PROC_ULIMIT), unlimited)
      PROC_ULIMIT := -1
    endif
  endif
  MEMORY_DIVIDER := 2048
  CHECK_JOBS := $(shell $(AWK) \
    'BEGIN { \
      c = $(NUM_CORES) / $(CORES_DIVIDER); \
      m = $(MEMORY_SIZE) / $(MEMORY_DIVIDER); \
      u = $(PROC_ULIMIT); \
      if (u > -1) { \
        u = u / $(ULIMIT_DIVIDER); \
        if (u < c) c = u; \
      } \
      if (c > m) c = m; \
      c = c * $(CHECK_JOBS_FACTOR); \
      c = c * $(CHECK_JOBS_FACTOR_JDL); \
      c = c * $(CHECK_JOBS_FACTOR_MACHINE); \
      if (c < 1) c = 1; \
      c = c + 0.5; \
      printf "%d", c; \
    }')
endif

################################################################################
# Parse control variables
################################################################################

ifneq ($(CHECK_OPTS), )
  # Inform the user
  $(info Running checks using CHECK_OPTS control variable '$(CHECK_OPTS)')
endif

### Jtreg

$(eval $(call SetCheckOpt,VM_OPTIONS,JTREG))
$(eval $(call SetCheckOpt,JAVA_OPTIONS,JTREG))

$(eval $(call SetCheckOpt,JOBS,JTREG))
$(eval $(call SetCheckOpt,TIMEOUT_FACTOR,JTREG))
$(eval $(call SetCheckOpt,FAILURE_HANDLER_TIMEOUT,JTREG))
$(eval $(call SetCheckOpt,REPORT,JTREG))

$(eval $(call ParseKeywordVariable, JTREG, \
    SINGLE_KEYWORDS := JOBS TIMEOUT_FACTOR FAILURE_HANDLER_TIMEOUT \
        CHECK_MODE ASSERT VERBOSE RETAIN CHECK_THREAD_FACTORY MAX_MEM RUN_PROBLEM_LISTS \
        RETRY_COUNT REPEAT_COUNT MAX_OUTPUT REPORT $(CUSTOM_JTREG_SINGLE_KEYWORDS), \
    STRING_KEYWORDS := OPTIONS JAVA_OPTIONS VM_OPTIONS KEYWORDS \
        EXTRA_PROBLEM_LISTS LAUNCHER_OPTIONS \
        $(CUSTOM_JTREG_STRING_KEYWORDS), \
))

ifneq ($(JTREG), )
  # Inform the user
  $(info Running checks using JTREG control variable '$(JTREG)')
endif

### Gcheck

$(eval $(call SetCheckOpt,VM_OPTIONS,GCHECK))
$(eval $(call SetCheckOpt,JAVA_OPTIONS,GCHECK))

$(eval $(call ParseKeywordVariable, GCHECK, \
    SINGLE_KEYWORDS := REPEAT, \
    STRING_KEYWORDS := OPTIONS VM_OPTIONS JAVA_OPTIONS, \
))

ifneq ($(GCHECK), )
  # Inform the user
  $(info Running checks using GCHECK control variable '$(GCHECK)')
endif

### Microbenchmarks

$(eval $(call SetCheckOpt,VM_OPTIONS,MICRO))
$(eval $(call SetCheckOpt,JAVA_OPTIONS,MICRO))

$(eval $(call ParseKeywordVariable, MICRO, \
    SINGLE_KEYWORDS := ITER FORK TIME WARMUP_ITER WARMUP_TIME, \
    STRING_KEYWORDS := OPTIONS JAVA_OPTIONS VM_OPTIONS RESULTS_FORMAT CHECK_JDK \
        BENCHMARKS_JAR, \
))

ifneq ($(MICRO), )
  # Inform the user
  $(info Running checks using MICRO control variable '$(MICRO)')
endif


################################################################################
# Component-specific Jtreg settings
################################################################################

hotspot_JTREG_MAX_MEM := 0
hotspot_JTREG_ASSERT := false
hotspot_JTREG_NATIVEPATH := $(CHECK_IMAGE_DIR)/hotspot/jtreg/native
jdk_JTREG_NATIVEPATH := $(CHECK_IMAGE_DIR)/jdk/jtreg/native
lib-check_JTREG_NATIVEPATH := $(CHECK_IMAGE_DIR)/lib-check/jtreg/native

jdk_JTREG_PROBLEM_LIST += $(TOPDIR)/check/jdk/ProblemList.txt
jaxp_JTREG_PROBLEM_LIST += $(TOPDIR)/check/jaxp/ProblemList.txt
langtools_JTREG_PROBLEM_LIST += $(TOPDIR)/check/langtools/ProblemList.txt
hotspot_JTREG_PROBLEM_LIST += $(TOPDIR)/check/hotspot/jtreg/ProblemList.txt
lib-check_JTREG_PROBLEM_LIST += $(TOPDIR)/check/lib-check/ProblemList.txt

################################################################################
# Parse check selection
#
# The user has given a check selection in the CHECK variable. We must parse it
# and determine what that means in terms of actual calls to the check framework.
#
# The parse functions take as argument a check specification as given by the
# user, and returns a fully qualified check descriptor if it was a match, or
# nothing if not. A single check specification can result in multiple check
# descriptors being returned. A valid check descriptor must always be accepted
# and returned identically.
################################################################################

# Helper function to determine if a check specification is a Gcheck check
#
# It is a Gcheck check if it is either "gcheck", or "gcheck:" followed by an optional
# check filter string, and an optional "/<variant>" to select a specific JVM
# variant. If no variant is specified, all found variants are checked.
define ParseGcheckCheckSelection
  $(if $(filter gcheck%, $1), \
    $(if $(filter gcheck, $1), \
      $(addprefix gcheck:all/, $(GCHECK_VARIANTS)) \
    , \
      $(if $(strip $(or $(filter gcheck/%, $1) $(filter gcheck:/%, $1))), \
        $(patsubst gcheck:/%, gcheck:all/%, $(patsubst gcheck/%, gcheck:/%, $1)) \
      , \
        $(if $(filter gcheck:%, $1), \
          $(if $(findstring /, $1), \
            $1 \
          , \
            $(addprefix $1/, $(GCHECK_VARIANTS)) \
          ) \
        ) \
      ) \
    ) \
  )
endef

# Helper function to determine if a check specification is a microbenchmark check
#
# It is a microbenchmark check if it is either "micro", or "micro:" followed by
# an optional check filter string.
define ParseMicroCheckSelection
  $(if $(filter micro%, $1), \
    $(if $(filter micro, $1), \
      micro:all \
    , \
      $(if $(filter micro:, $1), \
        micro:all \
      , \
        $1 \
      ) \
    ) \
  )
endef

# Helper function that removes the TOPDIR part
CleanupJtregPath = \
  $(strip $(patsubst %/, %, $(subst $(JTREG_TOPDIR)/,, $1)))

# Take a partial Jtreg root path and return a full, absolute path to that Jtreg
# root. Also support having "hotspot" as an alias for "hotspot/jtreg".
ExpandJtregRoot = \
  $(call CleanupJtregPath, $(wildcard \
    $(if $(filter /%, $1), \
      $(if $(wildcard $(strip $1)/CHECK.ROOT), \
        $1 \
      ) \
    , \
      $(filter $(addprefix %, $1), $(JTREG_CHECKROOTS) $(addsuffix /, $(JTREG_CHECKROOTS))) \
      $(filter $(addprefix %, $(strip $1)/jtreg), $(JTREG_CHECKROOTS) $(addsuffix /, $(JTREG_CHECKROOTS))) \
    ) \
  ))

# Take a partial Jtreg check path and return a full, absolute path to that Jtreg
# check. Also support having "hotspot" as an alias for "hotspot/jtreg".
ExpandJtregPath = \
  $(if $(call ExpandJtregRoot, $1), \
    $(call ExpandJtregRoot, $1) \
  , \
    $(call CleanupJtregPath, $(wildcard \
      $(if $(filter /%, $1), \
        $1 \
      , \
        $(addsuffix /$(strip $1), $(JTREG_CHECKROOTS) $(CHECK_BASEDIRS)) \
        $(addsuffix $(strip $(patsubst hotspot/%, /hotspot/jtreg/%, $1)), $(JTREG_CHECKROOTS) $(CHECK_BASEDIRS)) \
      ) \
    )) \
  )

# with check id: dir/Check.java#selection -> Check.java#selection -> .java#selection -> #selection
#      without: dir/Check.java           -> Check.java           -> .java           -> <<empty string>>
CheckID = \
    $(subst .jasm,,$(subst .sh,,$(subst .html,,$(subst .java,,$(suffix $(notdir $1))))))

# The check id starting with a hash (#checkid) will be stripped by all
# evals in ParseJtregCheckSelectionInner and will be reinserted by calling
# CheckID (if it is present).
ParseJtregCheckSelection = \
    $(call IfAppend, $(call ParseJtregCheckSelectionInner, $1), $(call CheckID, $1))

# Helper function to determine if a check specification is a Jtreg check
#
# It is a Jtreg check if it optionally begins with jtreg:, and then is either
# an unspecified group name (possibly prefixed by :), or a group in a
# specified check root, or a path to a check or check directory,
# either absolute or relative to any of the CHECK_BASEDIRS or check roots.
define ParseJtregCheckSelectionInner
  $(eval CHECK_NAME := $(strip $(patsubst jtreg:%, %, $1))) \
  $(if $(or $(findstring :, $(CHECK_NAME)), $(findstring /, $(CHECK_NAME))), , \
    $(eval CHECK_NAME := :$(CHECK_NAME)) \
  ) \
  $(if $(findstring :, $(CHECK_NAME)), \
    $(if $(filter :%, $(CHECK_NAME)), \
      $(eval CHECK_GROUP := $(patsubst :%, %, $(CHECK_NAME))) \
      $(eval CHECK_ROOTS := $(foreach check_root, $(JTREG_CHECKROOTS), \
          $(call CleanupJtregPath, $(check_root)))) \
    , \
      $(eval CHECK_PATH := $(word 1, $(subst :, $(SPACE), $(CHECK_NAME)))) \
      $(eval CHECK_GROUP := $(word 2, $(subst :, $(SPACE), $(CHECK_NAME)))) \
      $(eval CHECK_ROOTS := $(call ExpandJtregRoot, $(CHECK_PATH))) \
    ) \
    $(foreach check_root, $(CHECK_ROOTS), \
      $(if $(filter /%, $(check_root)), \
        jtreg:$(check_root):$(CHECK_GROUP) \
      , \
        $(if $(filter $(CHECK_GROUP), $($(JTREG_TOPDIR)/$(check_root)_JTREG_CHECK_GROUPS)), \
          jtreg:$(check_root):$(CHECK_GROUP) \
        ) \
      ) \
    ) \
  , \
    $(eval CHECK_PATHS := $(call ExpandJtregPath, $(CHECK_NAME))) \
    $(foreach check_path, $(CHECK_PATHS), \
      jtreg:$(check_path) \
    ) \
  )
endef

# Helper function to determine if a check specification is a special check
#
# It is a special check if it is "special:" followed by a check name,
# if it is "make:" or "make-" followed by a make check, or any of the special
# check names as a single word.
define ParseSpecialCheckSelection
  $(if $(filter special:%, $1), \
    $1 \
  ) \
  $(if $(filter make%, $1), \
    $(if $(filter make:%, $1), \
      special:$(strip $1) \
    ) \
    $(if $(filter make-%, $1), \
      special:$(patsubst make-%,make:%, $1) \
    ) \
    $(if $(filter make, $1), \
      special:make:all \
    )
  ) \
  $(if $(filter failure-handler, $1), \
    special:$(strip $1) \
  )
endef

ifeq ($(CHECK), )
  $(info No check selection given in CHECK!)
  $(info Please use e.g. 'make check CHECK=tier1' or 'make check-tier1')
  $(info See doc/checking.[md|html] for help)
  $(error Cannot continue)
endif

ParseCheckSelection = \
    $(strip $(or \
      $(call ParseCustomCheckSelection, $1) \
      $(call ParseGcheckCheckSelection, $1) \
      $(call ParseMicroCheckSelection, $1) \
      $(call ParseJtregCheckSelection, $1) \
      $(call ParseSpecialCheckSelection, $1) \
    ))

# Now intelligently convert the check selection given by the user in CHECK
# into a list of fully qualified check descriptors of the checks to run.
CHECKS_TO_RUN := $(strip $(foreach check, $(CHECK), $(call ParseCheckSelection, $(check))))
UNKNOWN_CHECK := $(strip $(foreach check, $(CHECK), $(if $(call ParseCheckSelection, $(check)), , $(check))))

ifneq ($(UNKNOWN_CHECK), )
  $(info Unknown check selection: '$(UNKNOWN_CHECK)')
  $(info See doc/checking.[md|html] for help)
  $(error Cannot continue)
endif

# Present the result of our parsing to the user
$(info Check selection '$(CHECK)', will run:)
$(foreach check, $(CHECKS_TO_RUN), $(info * $(check)))


################################################################################
# Functions for setting up rules for running the selected checks
#
# The SetupRun*Check functions all have the same interface:
#
# Parameter 1 is the name of the rule. This is the check id, based on the check
# descriptor, and this is also used as variable prefix, and the targets
# generated are listed in a variable by that name.
#
# Remaining parameters are named arguments. Currently this is only:
#   CHECK -- The properly formatted fully qualified check descriptor
#
# After the rule named by the check id has been executed, the following
# variables will be available:
# checkid_TOTAL - the total number of checks run
# checkid_PASSED - the number of successful checks
# checkid_FAILED - the number of failed checks
# checkid_ERROR - the number of checks was neither successful or failed
#
################################################################################

### Rules for Gcheck

SetupRunGcheckCheck = $(NamedParamsMacroTemplate)
define SetupRunGcheckCheckBody
  $1_CHECK_RESULTS_DIR := $$(CHECK_RESULTS_DIR)/$1
  $1_CHECK_SUPPORT_DIR := $$(CHECK_SUPPORT_DIR)/$1
  $1_EXITCODE := $$($1_CHECK_RESULTS_DIR)/exitcode.txt

  $1_VARIANT :=  $$(lastword $$(subst /, , $$($1_CHECK)))
  ifeq ($$(filter $$($1_VARIANT), $$(GCHECK_VARIANTS)), )
    $$(error Invalid gcheck variant '$$($1_VARIANT)'. Valid variants: $$(GCHECK_VARIANTS))
  endif
  $1_CHECK_NAME := $$(strip $$(patsubst %/$$($1_VARIANT), %, \
      $$(patsubst gcheck:%, %, $$($1_CHECK))))
  ifneq ($$($1_CHECK_NAME), all)
    $1_GCHECK_FILTER := --gcheck_filter=$$($1_CHECK_NAME)*
  endif

  ifneq ($$(GCHECK_REPEAT), )
    $1_GCHECK_REPEAT :=--gcheck_repeat=$$(GCHECK_REPEAT)
  endif

  run-check-$1: pre-run-check
	$$(call LogWarn)
	$$(call LogWarn, Running check '$$($1_CHECK)')
	$$(call MakeDir, $$($1_CHECK_RESULTS_DIR) $$($1_CHECK_SUPPORT_DIR))
	$$(call ExecuteWithLog, $$($1_CHECK_SUPPORT_DIR)/gcheck, ( \
	    $$(CD) $$($1_CHECK_SUPPORT_DIR) && \
	    $$(FIXPATH) $$(CHECK_IMAGE_DIR)/hotspot/gcheck/$$($1_VARIANT)/gcheckLauncher \
	        -jdk $(JDK_UNDER_CHECK) $$($1_GCHECK_FILTER) \
	        --gcheck_output=xml:$$($1_CHECK_RESULTS_DIR)/gcheck.xml \
	        --gcheck_catch_exceptions=0 \
	        $$($1_GCHECK_REPEAT) $$(GCHECK_OPTIONS) $$(GCHECK_VM_OPTIONS) \
	        $$(GCHECK_JAVA_OPTIONS) \
	        > >($(TEE) $$($1_CHECK_RESULTS_DIR)/gcheck.txt) \
	    && $$(ECHO) $$$$? > $$($1_EXITCODE) \
	    || $$(ECHO) $$$$? > $$($1_EXITCODE) \
	))

  $1_RESULT_FILE := $$($1_CHECK_RESULTS_DIR)/gcheck.txt

  parse-check-$1: run-check-$1
	$$(call LogWarn, Finished running check '$$($1_CHECK)')
	$$(call LogWarn, Check report is stored in $$(strip \
	    $$(subst $$(TOPDIR)/, , $$($1_CHECK_RESULTS_DIR))))
	$$(if $$(wildcard $$($1_RESULT_FILE)), \
	  $$(eval $1_TOTAL := $$(shell $$(AWK) '/==========.* checks? from .* \
	      check (cases?|suites?) ran/ { print $$$$2 }' $$($1_RESULT_FILE))) \
	  $$(if $$($1_TOTAL), , $$(eval $1_TOTAL := 0)) \
	  $$(eval $1_PASSED := $$(shell $$(AWK) '/\[  PASSED  \] .* checks?./ \
	      { print $$$$4 }' $$($1_RESULT_FILE))) \
	  $$(if $$($1_PASSED), , $$(eval $1_PASSED := 0)) \
	  $$(eval $1_FAILED := $$(shell $$(AWK) '/\[  FAILED  \] .* checks?, \
	      listed below/ { print $$$$4 }' $$($1_RESULT_FILE))) \
	  $$(if $$($1_FAILED), , $$(eval $1_FAILED := 0)) \
	  $$(eval $1_ERROR := $$(shell \
	      $$(EXPR) $$($1_TOTAL) - $$($1_PASSED) - $$($1_FAILED))) \
	, \
	  $$(eval $1_PASSED := 0) \
	  $$(eval $1_FAILED := 0) \
	  $$(eval $1_ERROR := 1) \
	  $$(eval $1_TOTAL := 1) \
	)

  $1: run-check-$1 parse-check-$1

  TARGETS += $1 run-check-$1 parse-check-$1
  CHECK_TARGETS += parse-check-$1

endef

################################################################################

### Rules for Microbenchmarks

# Helper function for SetupRunMicroCheck. Set a MICRO_* variable from, in order:
# 1) Specified by user on command line
# 2) Generic default
#
# Note: No spaces are allowed around the arguments.
# Arg $1 The check ID (i.e. $1 in SetupRunMicroCheck)
# Arg $2 Base variable, e.g. MICRO_CHECK_JDK
# Arg $3 The default value (optional)
define SetMicroValue
  ifneq ($$($2), )
    $1_$2 := $$($2)
  else
    ifneq ($3, )
      $1_$2 := $3
    endif
  endif
endef

SetupRunMicroCheck = $(NamedParamsMacroTemplate)
define SetupRunMicroCheckBody
  $1_CHECK_RESULTS_DIR := $$(CHECK_RESULTS_DIR)/$1
  $1_CHECK_SUPPORT_DIR := $$(CHECK_SUPPORT_DIR)/$1
  $1_EXITCODE := $$($1_CHECK_RESULTS_DIR)/exitcode.txt

  $1_CHECK_NAME := $$(strip $$(patsubst micro:%, %, $$($1_CHECK)))

  $$(eval $$(call SetMicroValue,$1,MICRO_BENCHMARKS_JAR,$$(CHECK_IMAGE_DIR)/micro/benchmarks.jar))
  $$(eval $$(call SetMicroValue,$1,MICRO_CHECK_JDK,$$(JDK_UNDER_CHECK)))
  $$(eval $$(call SetMicroValue,$1,MICRO_JAVA_OPTIONS))

  # Current checks needs to open java.io
  $1_MICRO_JAVA_OPTIONS += --add-opens=java.base/java.io=ALL-UNNAMED

  # Save output as JSON or CSV file
  ifneq ($$(MICRO_RESULTS_FORMAT), )
    $1_MICRO_BASIC_OPTIONS += -rf $$(MICRO_RESULTS_FORMAT)
    $1_MICRO_BASIC_OPTIONS += -rff $$($1_CHECK_RESULTS_DIR)/jmh-result.$(MICRO_RESULTS_FORMAT)
  endif

  # Set library path for native dependencies
  $1_JMH_JVM_ARGS := -Djava.library.path=$$(CHECK_IMAGE_DIR)/micro/native

  ifneq ($$(MICRO_VM_OPTIONS)$$(MICRO_JAVA_OPTIONS), )
    $1_JMH_JVM_ARGS += $$(MICRO_VM_OPTIONS) $$(MICRO_JAVA_OPTIONS)
  endif

  $1_MICRO_VM_OPTIONS := -jvmArgs $(call ShellQuote,$$($1_JMH_JVM_ARGS))

  ifneq ($$(MICRO_ITER), )
    $1_MICRO_ITER := -i $$(MICRO_ITER)
  endif
  ifneq ($$(MICRO_FORK), )
    $1_MICRO_FORK := -f $$(MICRO_FORK)
  endif
  ifneq ($$(MICRO_TIME), )
    $1_MICRO_TIME := -r $$(MICRO_TIME)
  endif
  ifneq ($$(MICRO_WARMUP_ITER), )
    $1_MICRO_WARMUP_ITER := -wi $$(MICRO_WARMUP_ITER)
  endif
  ifneq ($$(MICRO_WARMUP_TIME), )
    $1_MICRO_WARMUP_TIME := -w $$(MICRO_WARMUP_TIME)
  endif

# Microbenchmarks are executed from the root of the check image directory.
# This enables JMH checks to add dependencies using relative paths such as
# -Djava.library.path=micro/native

  run-check-$1: pre-run-check
	$$(call LogWarn)
	$$(call LogWarn, Running check '$$($1_CHECK)')
	$$(call MakeDir, $$($1_CHECK_RESULTS_DIR) $$($1_CHECK_SUPPORT_DIR))
	$$(call ExecuteWithLog, $$($1_CHECK_SUPPORT_DIR)/micro, ( \
	    $$(CD) $$(CHECK_IMAGE_DIR) && \
	    $$(FIXPATH) $$($1_MICRO_CHECK_JDK)/bin/java $$($1_MICRO_JAVA_OPTIONS) \
	        -jar $$($1_MICRO_BENCHMARKS_JAR) \
	        $$($1_MICRO_ITER) $$($1_MICRO_FORK) $$($1_MICRO_TIME) \
	        $$($1_MICRO_WARMUP_ITER) $$($1_MICRO_WARMUP_TIME) \
	        $$($1_MICRO_VM_OPTIONS) $$($1_MICRO_BASIC_OPTIONS) $$(MICRO_OPTIONS) \
	        $$($1_CHECK_NAME) \
	        > >($(TEE) $$($1_CHECK_RESULTS_DIR)/micro.txt) \
	    && $$(ECHO) $$$$? > $$($1_EXITCODE) \
	    || $$(ECHO) $$$$? > $$($1_EXITCODE) \
	))

  $1_RESULT_FILE := $$($1_CHECK_RESULTS_DIR)/micro.txt

  parse-check-$1: run-check-$1
	$$(call LogWarn, Finished running check '$$($1_CHECK)')
	$$(call LogWarn, Check report is stored in $$(strip \
	    $$(subst $$(TOPDIR)/, , $$($1_CHECK_RESULTS_DIR))))
	$$(if $$(wildcard $$($1_EXITCODE)), \
	  $$(eval $1_EXIT_CODE := $$(shell $$(CAT) $$($1_EXITCODE))) \
	  $$(if $$(filter 0, $$($1_EXIT_CODE)), \
	    $$(eval $1_PASSED := 1) \
	    $$(eval $1_ERROR := 0) \
	  , \
	    $$(eval $1_PASSED := 0) \
	    $$(eval $1_ERROR := 1) \
	  ) \
	  $$(eval $1_FAILED := 0) \
	  $$(eval $1_TOTAL := $$(shell \
	      $$(EXPR) $$($1_PASSED) + $$($1_ERROR))) \
	, \
	  $$(eval $1_PASSED := 0) \
	  $$(eval $1_FAILED := 0) \
	  $$(eval $1_ERROR := 1) \
	  $$(eval $1_TOTAL := 1) \
	)

  $1: run-check-$1 parse-check-$1

  TARGETS += $1 run-check-$1 parse-check-$1
  CHECK_TARGETS += parse-check-$1

endef

################################################################################

### Rules for Jtreg

# Helper function for SetupRunJtregCheck. Set a JTREG_* variable from, in order:
# 1) Specified by user on command line
# 2) Component-specific default
# 3) Generic default
#
# Note: No spaces are allowed around the arguments.
# Arg $1 The check ID (i.e. $1 in SetupRunJtregCheck)
# Arg $2 Base variable, e.g. JTREG_JOBS
# Arg $3 The default value (optional)
define SetJtregValue
  ifneq ($$($2), )
    $1_$2 := $$($2)
  else
    ifneq ($$($$($1_COMPONENT)_$2), )
      $1_$2 := $$($$($1_COMPONENT)_$2)
    else
      ifneq ($3, )
        $1_$2 := $3
      endif
    endif
  endif
endef

SetupRunJtregCheck = $(NamedParamsMacroTemplate)
define SetupRunJtregCheckBody
  $1_CHECK_RESULTS_DIR := $$(CHECK_RESULTS_DIR)/$1
  $1_CHECK_SUPPORT_DIR := $$(CHECK_SUPPORT_DIR)/$1
  $1_EXITCODE := $$($1_CHECK_RESULTS_DIR)/exitcode.txt

  $1_CHECK_NAME := $$(strip $$(patsubst jtreg:%, %, $$($1_CHECK)))

  $1_CHECK_ROOT := \
      $$(strip $$(foreach root, $$(JTREG_CHECKROOTS), \
        $$(if $$(filter $$(root)%, $$(JTREG_TOPDIR)/$$($1_CHECK_NAME)), $$(root)) \
      ))
  $1_COMPONENT := $$(lastword $$(subst /, $$(SPACE), $$($1_CHECK_ROOT)))
  # This will work only as long as just hotspot has the additional "jtreg" directory
  ifeq ($$($1_COMPONENT), jtreg)
    $1_COMPONENT := hotspot
  endif

  ifeq ($$(JT_HOME), )
    $$(info Error: jtreg framework is not found.)
    $$(info Please run configure using --with-jtreg.)
    $$(error Cannot continue)
  endif

  # Unfortunately, we need different defaults for some JTREG values,
  # depending on what component we're running.

  # Convert JTREG_foo into $1_JTREG_foo with a suitable value.
  $$(eval $$(call SetJtregValue,$1,JTREG_CHECK_MODE,agentvm))
  $$(eval $$(call SetJtregValue,$1,JTREG_ASSERT,true))
  $$(eval $$(call SetJtregValue,$1,JTREG_MAX_MEM,768m))
  $$(eval $$(call SetJtregValue,$1,JTREG_NATIVEPATH))
  $$(eval $$(call SetJtregValue,$1,JTREG_BASIC_OPTIONS))
  $$(eval $$(call SetJtregValue,$1,JTREG_PROBLEM_LIST))

  # Only the problem list for the current check root should be used.
  $1_JTREG_PROBLEM_LIST := $$(filter $$($1_CHECK_ROOT)%, $$($1_JTREG_PROBLEM_LIST))

  ifneq ($(CHECK_JOBS), 0)
    $$(eval $$(call SetJtregValue,$1,JTREG_JOBS,$$(CHECK_JOBS)))
  else
    $$(eval $$(call SetJtregValue,$1,JTREG_JOBS,$$(JOBS)))
  endif

  # Make sure MaxRAMPercentage is high enough to not cause OOM or swapping since
  # we may end up with a lot of JVM's
  $1_JTREG_MAX_RAM_PERCENTAGE := $$(shell $(AWK) 'BEGIN { print 25 / $$($1_JTREG_JOBS); }')

  JTREG_TIMEOUT_FACTOR ?= 4

  JTREG_VERBOSE ?= fail,error,summary
  JTREG_RETAIN ?= fail,error
  JTREG_CHECK_THREAD_FACTORY ?=
  JTREG_RUN_PROBLEM_LISTS ?= false
  JTREG_RETRY_COUNT ?= 0
  JTREG_REPEAT_COUNT ?= 0
  JTREG_REPORT ?= files

  ifneq ($$(JTREG_RETRY_COUNT), 0)
    ifneq ($$(JTREG_REPEAT_COUNT), 0)
      $$(info Error: Cannot use both JTREG_RETRY_COUNT and JTREG_REPEAT_COUNT together.)
      $$(info Please choose one or the other.)
      $$(error Cannot continue)
    endif
  endif

  ifneq ($$(JTREG_CHECK_THREAD_FACTORY), )
    $1_JTREG_BASIC_OPTIONS += -checkThreadFactoryPath:$$(JTREG_CHECK_THREAD_FACTORY_JAR)
    $1_JTREG_BASIC_OPTIONS += -checkThreadFactory:$$(JTREG_CHECK_THREAD_FACTORY)
    $1_JTREG_BASIC_OPTIONS += $$(addprefix $$(JTREG_PROBLEM_LIST_PREFIX), $$(wildcard \
	$$(addprefix $$($1_CHECK_ROOT)/, ProblemList-$$(JTREG_CHECK_THREAD_FACTORY).txt) \
    ))
  endif

  ifneq ($$(JTREG_LAUNCHER_OPTIONS), )
    $1_JTREG_LAUNCHER_OPTIONS += $$(JTREG_LAUNCHER_OPTIONS)
  endif

  ifneq ($$(JTREG_MAX_OUTPUT), )
    $1_JTREG_LAUNCHER_OPTIONS += -Djavacheck.maxOutputSize=$$(JTREG_MAX_OUTPUT)
  endif

  ifneq ($$($1_JTREG_MAX_MEM), 0)
    $1_JTREG_BASIC_OPTIONS += -vmoption:-Xmx$$($1_JTREG_MAX_MEM)
    $1_JTREG_LAUNCHER_OPTIONS += -Xmx$$($1_JTREG_MAX_MEM)
  endif

  # Make sure the tmp dir is normalized as some checks will react badly otherwise
  $1_CHECK_TMP_DIR := $$(abspath $$($1_CHECK_SUPPORT_DIR)/tmp)

  # check.boot.jdk is used by some check cases that want to execute a previous
  # version of the JDK.
  $1_JTREG_BASIC_OPTIONS += -$$($1_JTREG_CHECK_MODE) \
      -verbose:$$(JTREG_VERBOSE) -retain:$$(JTREG_RETAIN) \
      -concurrency:$$($1_JTREG_JOBS) -timeoutFactor:$$(JTREG_TIMEOUT_FACTOR) \
      -vmoption:-XX:MaxRAMPercentage=$$($1_JTREG_MAX_RAM_PERCENTAGE) \
      -vmoption:-Dcheck.boot.jdk="$$(BOOT_JDK)" \
      -vmoption:-Djava.io.tmpdir="$$($1_CHECK_TMP_DIR)"

  $1_JTREG_BASIC_OPTIONS += -automatic -ignore:quiet

  # Make it possible to specify the JIB_DATA_DIR for checks using the
  # JIB Artifact resolver
  $1_JTREG_BASIC_OPTIONS += -e:JIB_DATA_DIR
  # If running on Windows, propagate the _NT_SYMBOL_PATH to enable
  # symbol lookup in hserr files
  # The minidumps are disabled by default on client Windows, so enable them
  ifeq ($$(call isTargetOs, windows), true)
    $1_JTREG_BASIC_OPTIONS += -e:_NT_SYMBOL_PATH
    $1_JTREG_BASIC_OPTIONS += -vmoption:-XX:+CreateCoredumpOnCrash
  else ifeq ($$(call isTargetOs, linux), true)
      $1_JTREG_BASIC_OPTIONS += -e:_JVM_DWARF_PATH=$$(SYMBOLS_IMAGE_DIR)
  endif

  $1_JTREG_BASIC_OPTIONS += \
      $$(addprefix -javaoption:, $$(JTREG_JAVA_OPTIONS)) \
      $$(addprefix -vmoption:, $$(JTREG_VM_OPTIONS)) \
      #

  ifeq ($$($1_JTREG_ASSERT), true)
    $1_JTREG_BASIC_OPTIONS += -ea -esa
  endif

  ifneq ($$($1_JTREG_NATIVEPATH), )
    $1_JTREG_BASIC_OPTIONS += -nativepath:$$($1_JTREG_NATIVEPATH)
  endif

  ifeq ($$(JTREG_RUN_PROBLEM_LISTS), true)
    JTREG_PROBLEM_LIST_PREFIX := -match:
  else
    JTREG_PROBLEM_LIST_PREFIX := -exclude:
  endif

  ifneq ($$($1_JTREG_PROBLEM_LIST), )
    $1_JTREG_BASIC_OPTIONS += $$(addprefix $$(JTREG_PROBLEM_LIST_PREFIX), $$($1_JTREG_PROBLEM_LIST))
  endif

  ifneq ($$(JTREG_EXTRA_PROBLEM_LISTS), )
    # Accept both absolute paths as well as relative to the current check root.
    $1_JTREG_BASIC_OPTIONS += $$(addprefix $$(JTREG_PROBLEM_LIST_PREFIX), $$(wildcard \
        $$(JTREG_EXTRA_PROBLEM_LISTS) \
        $$(addprefix $$($1_CHECK_ROOT)/, $$(JTREG_EXTRA_PROBLEM_LISTS)) \
    ))
  endif

  ifneq ($$(JIB_HOME), )
    $1_JTREG_BASIC_OPTIONS += -e:JIB_HOME=$$(JIB_HOME)
  endif

  $1_JTREG_BASIC_OPTIONS += -e:CHECK_IMAGE_DIR=$(CHECK_IMAGE_DIR)

  ifneq ($$(JTREG_FAILURE_HANDLER_OPTIONS), )
    $1_JTREG_LAUNCHER_OPTIONS += -Djava.library.path="$(JTREG_FAILURE_HANDLER_DIR)"
  endif

  ifneq ($$(JTREG_KEYWORDS), )
    # The keywords string may contain problematic characters and may be quoted
    # already when it arrives here. Remove any existing quotes and replace them
    # with one set of single quotes.
    $1_JTREG_KEYWORDS := \
        $$(strip $$(subst $$(SQUOTE),,$$(subst $$(DQUOTE),,$$(JTREG_KEYWORDS))))
    ifneq ($$($1_JTREG_KEYWORDS), )
      $1_JTREG_BASIC_OPTIONS += -k:'$$($1_JTREG_KEYWORDS)'
    endif
  endif

  $$(eval $$(call SetupRunJtregCheckCustom, $1))

  clean-outputdirs-$1:
	$$(RM) -r $$($1_CHECK_SUPPORT_DIR)
	$$(RM) -r $$($1_CHECK_RESULTS_DIR)

  $1_COMMAND_LINE := \
      $$(JTREG_JAVA) $$($1_JTREG_LAUNCHER_OPTIONS) \
          -Dprogram=jtreg -jar $$(JT_HOME)/lib/jtreg.jar \
          $$($1_JTREG_BASIC_OPTIONS) \
          -checkjdk:$$(JDK_UNDER_CHECK) \
          -dir:$$(JTREG_TOPDIR) \
          -reportDir:$$($1_CHECK_RESULTS_DIR) \
          -workDir:$$($1_CHECK_SUPPORT_DIR) \
          -report:$${JTREG_REPORT} \
          $$$${JTREG_STATUS} \
          $$(JTREG_OPTIONS) \
          $$(JTREG_FAILURE_HANDLER_OPTIONS) \
          $$(JTREG_COV_OPTIONS) \
          $$($1_CHECK_NAME) \
      && $$(ECHO) $$$$? > $$($1_EXITCODE) \
      || $$(ECHO) $$$$? > $$($1_EXITCODE)


  ifneq ($$(JTREG_RETRY_COUNT), 0)
    $1_COMMAND_LINE := \
        for i in {0..$$(JTREG_RETRY_COUNT)}; do \
          if [ "$$$$i" != 0 ]; then \
            $$(PRINTF) "\nRetrying Jtreg run. Attempt: $$$$i\n"; \
          fi; \
          $$($1_COMMAND_LINE); \
          if [ "`$$(CAT) $$($1_EXITCODE)`" = "0" ]; then \
            break; \
          fi; \
          export JTREG_STATUS="-status:error,fail"; \
        done
  endif

  ifneq ($$(JTREG_REPEAT_COUNT), 0)
    $1_COMMAND_LINE := \
        for i in {1..$$(JTREG_REPEAT_COUNT)}; do \
          $$(PRINTF) "\nRepeating Jtreg run: $$$$i out of $$(JTREG_REPEAT_COUNT)\n"; \
          $$($1_COMMAND_LINE); \
          if [ "`$$(CAT) $$($1_EXITCODE)`" != "0" ]; then \
            $$(PRINTF) "\nFailures detected, no more repeats.\n"; \
            break; \
          fi; \
        done
  endif

  run-check-$1: pre-run-check clean-outputdirs-$1
	$$(call LogWarn)
	$$(call LogWarn, Running check '$$($1_CHECK)')
	$$(call MakeDir, $$($1_CHECK_RESULTS_DIR) $$($1_CHECK_SUPPORT_DIR) \
	    $$($1_CHECK_TMP_DIR))
	$$(call ExecuteWithLog, $$($1_CHECK_SUPPORT_DIR)/jtreg, ( \
            $$(COV_ENVIRONMENT) $$($1_COMMAND_LINE) \
	))

  $1_RESULT_FILE := $$($1_CHECK_RESULTS_DIR)/text/stats.txt

  parse-check-$1: run-check-$1
	$$(call LogWarn, Finished running check '$$($1_CHECK)')
	$$(call LogWarn, Check report is stored in $$(strip \
	    $$(subst $$(TOPDIR)/, , $$($1_CHECK_RESULTS_DIR))))
	$$(if $$(wildcard $$($1_RESULT_FILE)), \
	  $$(eval $1_PASSED := $$(shell $$(AWK) '{ gsub(/[,;]/, ""); \
	      for (i=1; i<=NF; i++) { if ($$$$i == "passed:") \
	      print $$$$(i+1) } }' $$($1_RESULT_FILE))) \
	  $$(if $$($1_PASSED), , $$(eval $1_PASSED := 0)) \
	  $$(eval $1_FAILED := $$(shell $$(AWK) '{gsub(/[,;]/, ""); \
	      for (i=1; i<=NF; i++) { if ($$$$i == "failed:") \
	      print $$$$(i+1) } }' $$($1_RESULT_FILE))) \
	  $$(if $$($1_FAILED), , $$(eval $1_FAILED := 0)) \
	  $$(eval $1_ERROR := $$(shell $$(AWK) '{gsub(/[,;]/, ""); \
	      for (i=1; i<=NF; i++) { if ($$$$i == "error:") \
	      print $$$$(i+1) } }' $$($1_RESULT_FILE))) \
	  $$(if $$($1_ERROR), , $$(eval $1_ERROR := 0)) \
	  $$(eval $1_TOTAL := $$(shell \
	      $$(EXPR) $$($1_PASSED) + $$($1_FAILED) + $$($1_ERROR))) \
	, \
	  $$(eval $1_PASSED := 0) \
	  $$(eval $1_FAILED := 0) \
	  $$(eval $1_ERROR := 1) \
	  $$(eval $1_TOTAL := 1) \
	)

  $1: run-check-$1 parse-check-$1 clean-outputdirs-$1

  TARGETS += $1 run-check-$1 parse-check-$1 clean-outputdirs-$1
  CHECK_TARGETS += parse-check-$1

endef

################################################################################

### Rules for special checks

SetupRunSpecialCheck = $(NamedParamsMacroTemplate)
define SetupRunSpecialCheckBody
  $1_CHECK_RESULTS_DIR := $$(CHECK_RESULTS_DIR)/$1
  $1_CHECK_SUPPORT_DIR := $$(CHECK_SUPPORT_DIR)/$1
  $1_EXITCODE := $$($1_CHECK_RESULTS_DIR)/exitcode.txt

  $1_FULL_CHECK_NAME := $$(strip $$(patsubst special:%, %, $$($1_CHECK)))
  ifneq ($$(findstring :, $$($1_FULL_CHECK_NAME)), )
    $1_CHECK_NAME := $$(firstword $$(subst :, ,$$($1_FULL_CHECK_NAME)))
    $1_CHECK_ARGS := $$(strip $$(patsubst special:$$($1_CHECK_NAME):%, %, $$($1_CHECK)))
  else
    $1_CHECK_NAME := $$($1_FULL_CHECK_NAME)
    $1_CHECK_ARGS :=
  endif

  ifeq ($$($1_CHECK_NAME), failure-handler)
    ifeq ($(BUILD_FAILURE_HANDLER), true)
      $1_CHECK_COMMAND_LINE := \
          ($(CD) $(TOPDIR)/make/check && $(MAKE) $(MAKE_ARGS) -f \
          BuildFailureHandler.gmk check)
    else
      $$(error Cannot check failure handler if it is not built)
    endif
  else ifeq ($$($1_CHECK_NAME), make)
    $1_CHECK_COMMAND_LINE := \
        ($(CD) $(TOPDIR)/check/make && $(MAKE) $(MAKE_ARGS) -f \
        CheckMake.gmk $$($1_CHECK_ARGS) CHECK_SUPPORT_DIR="$$($1_CHECK_SUPPORT_DIR)")
  else
    $$(error Invalid special check specification: $$($1_CHECK_NAME))
  endif

  run-check-$1: pre-run-check
	$$(call LogWarn)
	$$(call LogWarn, Running check '$$($1_CHECK)')
	$$(call MakeDir, $$($1_CHECK_RESULTS_DIR) $$($1_CHECK_SUPPORT_DIR))
	$$(call ExecuteWithLog, $$($1_CHECK_SUPPORT_DIR)/check-execution, ( \
	    $$($1_CHECK_COMMAND_LINE) \
	        > >($(TEE) $$($1_CHECK_RESULTS_DIR)/check-output.txt) \
	    && $$(ECHO) $$$$? > $$($1_EXITCODE) \
	    || $$(ECHO) $$$$? > $$($1_EXITCODE) \
	))

  $1_RESULT_FILE := $$($1_CHECK_RESULTS_DIR)/gcheck.txt

  # We can not parse the various "special" checks.
  parse-check-$1: run-check-$1
	$$(call LogWarn, Finished running check '$$($1_CHECK)')
	$$(call LogWarn, Check report is stored in $$(strip \
	    $$(subst $$(TOPDIR)/, , $$($1_CHECK_RESULTS_DIR))))
	$$(call LogWarn, Warning: Special check results are not properly parsed!)
	$$(eval $1_PASSED := $$(shell \
	  if [ `$(CAT) $$($1_EXITCODE)` = "0" ]; then $(ECHO) 1; else $(ECHO) 0; fi \
	))
	$$(eval $1_FAILED := $$(shell \
	  if [ `$(CAT) $$($1_EXITCODE)` = "0" ]; then $(ECHO) 0; else $(ECHO) 1; fi \
	))
	$$(eval $1_ERROR := 0)
	$$(eval $1_TOTAL := 1)

  $1: run-check-$1 parse-check-$1

  TARGETS += $1 run-check-$1 parse-check-$1
  CHECK_TARGETS += parse-check-$1

endef

################################################################################
# Setup and execute make rules for all selected checks
################################################################################

# Helper function to determine which handler to use for the given check
UseGcheckCheckHandler = \
  $(if $(filter gcheck:%, $1), true)

UseMicroCheckHandler = \
  $(if $(filter micro:%, $1), true)

UseJtregCheckHandler = \
  $(if $(filter jtreg:%, $1), true)

UseSpecialCheckHandler = \
  $(if $(filter special:%, $1), true)

# Now process each check to run and setup a proper make rule
$(foreach check, $(CHECKS_TO_RUN), \
  $(eval CHECK_ID := $(shell $(ECHO) $(strip $(check)) | \
      $(TR) -cs '[a-z][A-Z][0-9]\n' '[_*1000]')) \
  $(eval ALL_CHECK_IDS += $(CHECK_ID)) \
  $(if $(call UseCustomCheckHandler, $(check)), \
    $(eval $(call SetupRunCustomCheck, $(CHECK_ID), \
        CHECK := $(check), \
    )) \
  ) \
  $(if $(call UseGcheckCheckHandler, $(check)), \
    $(eval $(call SetupRunGcheckCheck, $(CHECK_ID), \
        CHECK := $(check), \
    )) \
  ) \
  $(if $(call UseMicroCheckHandler, $(check)), \
    $(eval $(call SetupRunMicroCheck, $(CHECK_ID), \
        CHECK := $(check), \
    )) \
  ) \
  $(if $(call UseJtregCheckHandler, $(check)), \
    $(eval $(call SetupRunJtregCheck, $(CHECK_ID), \
        CHECK := $(check), \
    )) \
  ) \
  $(if $(call UseSpecialCheckHandler, $(check)), \
    $(eval $(call SetupRunSpecialCheck, $(CHECK_ID), \
        CHECK := $(check), \
    )) \
  ) \
)

# Sort also removes duplicates, so if there is any we'll get fewer words.
ifneq ($(words $(ALL_CHECK_IDS)), $(words $(sort $(ALL_CHECK_IDS))))
  $(error Duplicate check specification)
endif


################################################################################
# The main target for RunChecks.gmk
################################################################################

#
# Provide hooks for adding functionality before and after all checks are run.
#

$(call LogInfo, RunCheck setup starting)

# This target depends on all actual check having been run (CHECK_TARGETS has beeen
# populated by the SetupRun*Check functions). If you need to provide a teardown
# hook, you must let it depend on this target.
run-all-checks: $(CHECK_TARGETS)
	$(call LogInfo, RunCheck teardown starting)

# This is an abstract target that will be run before any actual checks. Add your
# target as a dependency to thisif you need "setup" type functionality executed
# before all checks.
pre-run-check:
	$(call LogInfo, RunCheck setup done)

# This is an abstract target that will be run after all actual checks, but before
# the check summary. If you need "teardown" type functionality, add your target
# as a dependency on this, and let the teardown target depend on run-all-checks.
post-run-check: run-all-checks
	$(call LogInfo, RunCheck teardown done)

#
# Create and print a table of the result of all checks run
#
CHECK_FAILURE := false

run-check-report: post-run-check
	$(RM) $(CHECK_SUMMARY).old 2> /dev/null
	$(MV) $(CHECK_SUMMARY) $(CHECK_SUMMARY).old 2> /dev/null || true
	$(RM) $(CHECK_LAST_IDS).old 2> /dev/null
	$(MV) $(CHECK_LAST_IDS) $(CHECK_LAST_IDS).old 2> /dev/null || true
	$(ECHO) >> $(CHECK_SUMMARY) ==============================
	$(ECHO) >> $(CHECK_SUMMARY) Check summary
	$(ECHO) >> $(CHECK_SUMMARY) ==============================
	$(PRINTF) >> $(CHECK_SUMMARY) "%2s %-49s %5s %5s %5s %5s %2s\n" "  " \
	    CHECK TOTAL PASS FAIL ERROR " "
	$(foreach check, $(CHECKS_TO_RUN), \
	  $(eval CHECK_ID := $(shell $(ECHO) $(strip $(check)) | \
	      $(TR) -cs '[a-z][A-Z][0-9]\n' '[_*1000]')) \
	    $(ECHO) >> $(CHECK_LAST_IDS) $(CHECK_ID) $(NEWLINE) \
	  $(eval NAME_PATTERN := $(shell $(ECHO) $(check) | $(TR) -c '\n' '[_*1000]')) \
	  $(if $(filter __________________________________________________%, $(NAME_PATTERN)), \
	    $(eval CHECK_NAME := ) \
	    $(PRINTF) >> $(CHECK_SUMMARY) "%2s %-49s\n" "  " "$(check)"  $(NEWLINE) \
	  , \
	    $(eval CHECK_NAME := $(check)) \
	  ) \
	  $(if $(filter $($(CHECK_ID)_PASSED), $($(CHECK_ID)_TOTAL)), \
	    $(PRINTF) >> $(CHECK_SUMMARY) "%2s %-49s %5d %5d %5d %5d %2s\n" \
	        "  " "$(CHECK_NAME)" $($(CHECK_ID)_TOTAL) $($(CHECK_ID)_PASSED) \
	        $($(CHECK_ID)_FAILED) $($(CHECK_ID)_ERROR) "  " $(NEWLINE) \
	  , \
	    $(PRINTF) >> $(CHECK_SUMMARY) "%2s %-49s %5d %5d %5d %5d %2s\n" \
	         ">>" "$(CHECK_NAME)" $($(CHECK_ID)_TOTAL) $($(CHECK_ID)_PASSED) \
	        $($(CHECK_ID)_FAILED) $($(CHECK_ID)_ERROR) "<<" $(NEWLINE) \
	    $(eval CHECK_FAILURE := true) \
	  ) \
	)
	$(ECHO) >> $(CHECK_SUMMARY) ==============================
	$(if $(filter true, $(CHECK_FAILURE)), \
	  $(ECHO) >> $(CHECK_SUMMARY) CHECK FAILURE $(NEWLINE) \
	  $(MKDIR) -p $(MAKESUPPORT_OUTPUTDIR) $(NEWLINE) \
	  $(TOUCH) $(MAKESUPPORT_OUTPUTDIR)/exit-with-error \
	, \
	  $(ECHO) >> $(CHECK_SUMMARY) CHECK SUCCESS \
	)
	$(ECHO)
	$(CAT) $(CHECK_SUMMARY)
	$(ECHO)

# The main run-check target
run-check: run-check-report

TARGETS += run-all-checks pre-run-check post-run-check run-check-report run-check

################################################################################
# Setup JCov
################################################################################

ifeq ($(CHECK_OPTS_JCOV), true)

  jcov-do-start-grabber:
	$(call MakeDir, $(JCOV_OUTPUT_DIR))
	if $(JAVA) -jar $(JCOV_HOME)/lib/jcov.jar GrabberManager -status 1>/dev/null 2>&1 ; then \
	  $(JAVA) -jar $(JCOV_HOME)/lib/jcov.jar GrabberManager -stop -stoptimeout 3600 ; \
	fi
	$(JAVA) -Xmx4g -jar $(JCOV_HOME)/lib/jcov.jar Grabber -v -t \
	    $(JCOV_IMAGE_DIR)/template.xml -o $(JCOV_RESULT_FILE) \
	    1>$(JCOV_GRABBER_LOG) 2>&1 &

  jcov-start-grabber: jcov-do-start-grabber
	$(call LogWarn, Starting JCov Grabber...)
	$(JAVA) -jar $(JCOV_HOME)/lib/jcov.jar GrabberManager -t 600 -wait

  jcov-stop-grabber:
	$(call LogWarn, Stopping JCov Grabber...)
	$(JAVA) -jar $(JCOV_HOME)/lib/jcov.jar GrabberManager -stop -stoptimeout 3600

  JCOV_REPORT_TITLE := JDK code coverage report<br/>
  ifneq ($(JCOV_FILTERS), )
    JCOV_REPORT_TITLE += Code filters: $(JCOV_FILTERS)<br>
  endif
  JCOV_REPORT_TITLE += Checks: $(CHECK)

  jcov-gen-report: jcov-stop-grabber
	$(call LogWarn, Generating JCov report ...)
	$(JAVA) -Xmx4g -jar $(JCOV_HOME)/lib/jcov.jar RepGen -sourcepath \
	    `$(ECHO) $(TOPDIR)/src/*/share/classes/ | $(TR) ' ' ':'` -fmt html \
	    $(JCOV_FILTERS) \
	    -mainReportTitle "$(JCOV_REPORT_TITLE)" \
	    -o $(JCOV_REPORT) $(JCOV_RESULT_FILE)

  TARGETS += jcov-do-start-grabber jcov-start-grabber jcov-stop-grabber \
      jcov-gen-report

  ifneq ($(CHECK_OPTS_JCOV_DIFF_CHANGESET), )

    JCOV_SOURCE_DIFF := $(JCOV_OUTPUT_DIR)/source_diff
    JCOV_DIFF_COVERAGE_REPORT := $(JCOV_OUTPUT_DIR)/diff_coverage_report

    ifneq ($(and $(GIT), $(wildcard $(TOPDIR)/.git)), )
      DIFF_COMMAND := $(GIT) -C $(TOPDIR) diff $(CHECK_OPTS_JCOV_DIFF_CHANGESET) > $(JCOV_SOURCE_DIFF)
    else
      $(info Error: Must be a git source tree for diff coverage.)
      $(error No git source tree.)
    endif

    jcov-gen-diffcoverage: jcov-stop-grabber
	$(call LogWarn, Generating diff coverage with changeset $(CHECK_OPTS_JCOV_DIFF_CHANGESET) ... )
	$(DIFF_COMMAND)
	$(JAVA) -Xmx4g -jar $(JCOV_HOME)/lib/jcov.jar \
	  DiffCoverage -replaceDiff "src/.*/classes/:" -all \
	    $(JCOV_RESULT_FILE) $(JCOV_SOURCE_DIFF) > \
	    $(JCOV_DIFF_COVERAGE_REPORT)

    TARGETS += jcov-gen-diffcoverage

  endif

  # Hook this into the framework at appropriate places
  pre-run-check: jcov-start-grabber

  post-run-check: jcov-gen-report

  ifneq ($(CHECK_OPTS_JCOV_DIFF_CHANGESET), )

    post-run-check: jcov-gen-diffcoverage

  endif

  jcov-stop-grabber: run-all-checks

endif

################################################################################

all: run-check

.PHONY: default all $(TARGETS)
