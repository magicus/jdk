#
# Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
#
# This code is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 2 only, as
# published by the Free Software Foundation.  Oracle designates this
# particular file as subject to the "Classpath" exception as provided
# by Oracle in the LICENSE file that accompanied this code.
#
# This code is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# version 2 for more details (a copy is included in the LICENSE file that
# accompanied this code).
#
# You should have received a copy of the GNU General Public License version
# 2 along with this work; if not, write to the Free Software Foundation,
# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
# or visit www.oracle.com if you need additional information or have any
# questions.
#

default: all

include $(SPEC)
include MakeBase.gmk

# We will always run multiple checks serially
.NOTPARALLEL:

################################################################################
# Hook to include the corresponding custom file, if present.
$(eval $(call IncludeCustomExtension, RunChecks.gmk))
################################################################################

# This is the JDK that we will check
JDK_UNDER_CHECK := $(JDK_IMAGE_DIR)

CHECK_RESULTS_DIR := $(OUTPUTDIR)/check-results
CHECK_SUPPORT_DIR := $(OUTPUTDIR)/check-support
CHECK_SUMMARY := $(CHECK_RESULTS_DIR)/check-summary.txt
CHECK_LAST_IDS := $(CHECK_SUPPORT_DIR)/check-last-ids.txt

################################################################################
# Parse check selection
#
# The user has given a check selection in the CHECK variable. We must parse it
# and determine what that means in terms of actual calls to the check framework.
#
# The parse functions take as argument a check specification as given by the
# user, and returns a fully qualified check descriptor if it was a match, or
# nothing if not. A single check specification can result in multiple check
# descriptors being returned. A valid check descriptor must always be accepted
# and returned identically.
################################################################################

# Helper function to determine if a check specification is a modifier-order check
#
# It is a modifier-order check if it is either "modifier-order", or "modifier-order:" followed by
# an optional check filter string.
define ParseModifierOrderCheckSelection
  $(if $(filter modifier-order%, $1), \
    $(if $(filter modifier-order, $1), \
      modifier-order:all \
    , \
      $(if $(filter modifier-order:, $1), \
        modifier-order:all \
      , \
        $1 \
      ) \
    ) \
  )
endef

ifeq ($(CHECK), )
  $(info No check selection given in CHECK!)
  $(info Please use e.g. 'make check CHECK=modifier-order' or 'make check-modifier-order')
  $(info See doc/checking.[md|html] for help)
  $(error Cannot continue)
endif

ParseCheckSelection = \
    $(strip $(or \
      $(call ParseModifierOrderCheckSelection, $1) \
    ))

# Now intelligently convert the check selection given by the user in CHECK
# into a list of fully qualified check descriptors of the checks to run.
CHECKS_TO_RUN := $(strip $(foreach check, $(CHECK), $(call ParseCheckSelection, $(check))))
UNKNOWN_CHECK := $(strip $(foreach check, $(CHECK), $(if $(call ParseCheckSelection, $(check)), , $(check))))

ifneq ($(UNKNOWN_CHECK), )
  $(info Unknown check selection: '$(UNKNOWN_CHECK)')
  $(info See doc/checking.[md|html] for help)
  $(error Cannot continue)
endif

# Present the result of our parsing to the user
$(info Check selection '$(CHECK)', will run:)
$(foreach check, $(CHECKS_TO_RUN), $(info * $(check)))

################################################################################
# Functions for setting up rules for running the selected checks
#
# The SetupRun*Check functions all have the same interface:
#
# Parameter 1 is the name of the rule. This is the check id, based on the check
# descriptor, and this is also used as variable prefix, and the targets
# generated are listed in a variable by that name.
#
# Remaining parameters are named arguments. Currently this is only:
#   CHECK -- The properly formatted fully qualified check descriptor
#
################################################################################

### Rules for ModifierOrder

# Helper function for SetupRunModifierOrderCheck. Set a MODIFIER_ORDER_* variable from, in order:
# 1) Specified by user on command line
# 2) Generic default
#
# Note: No spaces are allowed around the arguments.
# Arg $1 The check ID (i.e. $1 in SetupRunModifierOrderCheck)
# Arg $2 Base variable, e.g. MODIFIER_ORDER_CHECK_JDK
# Arg $3 The default value (optional)
define SetModifierOrderValue
  ifneq ($$($2), )
    $1_$2 := $$($2)
  else
    ifneq ($3, )
      $1_$2 := $3
    endif
  endif
endef

SetupRunModifierOrderCheck = $(NamedParamsMacroTemplate)
define SetupRunModifierOrderCheckBody
  $1_CHECK_RESULTS_DIR := $$(CHECK_RESULTS_DIR)/$1
  $1_CHECK_SUPPORT_DIR := $$(CHECK_SUPPORT_DIR)/$1
  $1_EXITCODE := $$($1_CHECK_RESULTS_DIR)/exitcode.txt

  $1_CHECK_NAME := $$(strip $$(patsubst modifier-order:%, %, $$($1_CHECK)))

  $$(eval $$(call SetModifierOrderValue,$1,MODIFIER_ORDER_BENCHMARKS_JAR,$$(CHECK_IMAGE_DIR)/modifier-order/benchmarks.jar))
  $$(eval $$(call SetModifierOrderValue,$1,MODIFIER_ORDER_CHECK_JDK,$$(JDK_UNDER_CHECK)))
  $$(eval $$(call SetModifierOrderValue,$1,MODIFIER_ORDER_JAVA_OPTIONS))

  # Current checks needs to open java.io
  $1_MODIFIER_ORDER_JAVA_OPTIONS += --add-opens=java.base/java.io=ALL-UNNAMED


# ModifierOrder are executed from the root of the check image directory.
# This enables JMH checks to add dependencies using relative paths such as
# -Djava.library.path=modifier-order/native

  run-check-$1: pre-run-check
	$$(call LogWarn)
	$$(call LogWarn, Running check '$$($1_CHECK)')
	$$(call MakeDir, $$($1_CHECK_RESULTS_DIR) $$($1_CHECK_SUPPORT_DIR))
	$$(call ExecuteWithLog, $$($1_CHECK_SUPPORT_DIR)/modifier-order, ( \
	    $$(CD) $$(CHECK_IMAGE_DIR) && \
	    $$(FIXPATH) $$($1_MODIFIER_ORDER_CHECK_JDK)/bin/java $$($1_MODIFIER_ORDER_JAVA_OPTIONS) \
	        -jar $$($1_MODIFIER_ORDER_BENCHMARKS_JAR) \
	        $$($1_MODIFIER_ORDER_ITER) $$($1_MODIFIER_ORDER_FORK) $$($1_MODIFIER_ORDER_TIME) \
	        $$($1_MODIFIER_ORDER_WARMUP_ITER) $$($1_MODIFIER_ORDER_WARMUP_TIME) \
	        $$($1_MODIFIER_ORDER_VM_OPTIONS) $$($1_MODIFIER_ORDER_BASIC_OPTIONS) $$(MODIFIER_ORDER_OPTIONS) \
	        $$($1_CHECK_NAME) \
	        > >($(TEE) $$($1_CHECK_RESULTS_DIR)/modifier-order.txt) \
	    && $$(ECHO) $$$$? > $$($1_EXITCODE) \
	    || $$(ECHO) $$$$? > $$($1_EXITCODE) \
	))

  $1_RESULT_FILE := $$($1_CHECK_RESULTS_DIR)/modifier-order.txt

  parse-check-$1: run-check-$1
	$$(call LogWarn, Finished running check '$$($1_CHECK)')
	$$(call LogWarn, Check report is stored in $$(strip \
	    $$(subst $$(TOPDIR)/, , $$($1_CHECK_RESULTS_DIR))))

  $1: run-check-$1 parse-check-$1

  TARGETS += $1 run-check-$1 parse-check-$1
  CHECK_TARGETS += parse-check-$1

endef

################################################################################
# Setup and execute make rules for all selected checks
################################################################################

# Helper function to determine which handler to use for the given check
UseModifierOrderCheckHandler = \
  $(if $(filter modifier-order:%, $1), true)

# Now process each check to run and setup a proper make rule
$(foreach check, $(CHECKS_TO_RUN), \
  $(eval CHECK_ID := $(shell $(ECHO) $(strip $(check)) | \
      $(TR) -cs '[a-z][A-Z][0-9]\n' '[_*1000]')) \
  $(eval ALL_CHECK_IDS += $(CHECK_ID)) \
  $(if $(call UseCustomCheckHandler, $(check)), \
    $(eval $(call SetupRunCustomCheck, $(CHECK_ID), \
        CHECK := $(check), \
    )) \
  ) \
  $(if $(call UseModifierOrderCheckHandler, $(check)), \
    $(eval $(call SetupRunModifierOrderCheck, $(CHECK_ID), \
        CHECK := $(check), \
    )) \
  ) \
)

# Sort also removes duplicates, so if there is any we'll get fewer words.
ifneq ($(words $(ALL_CHECK_IDS)), $(words $(sort $(ALL_CHECK_IDS))))
  $(error Duplicate check specification)
endif

################################################################################
# The main target for RunChecks.gmk
################################################################################

#
# Provide hooks for adding functionality before and after all checks are run.
#

$(call LogInfo, RunCheck setup starting)

# This target depends on all actual check having been run (CHECK_TARGETS has beeen
# populated by the SetupRun*Check functions). If you need to provide a teardown
# hook, you must let it depend on this target.
run-all-checks: $(CHECK_TARGETS)
	$(call LogInfo, RunCheck teardown starting)

# This is an abstract target that will be run before any actual checks. Add your
# target as a dependency to thisif you need "setup" type functionality executed
# before all checks.
pre-run-check:
	$(call LogInfo, RunCheck setup done)

# This is an abstract target that will be run after all actual checks, but before
# the check summary. If you need "teardown" type functionality, add your target
# as a dependency on this, and let the teardown target depend on run-all-checks.
post-run-check: run-all-checks
	$(call LogInfo, RunCheck teardown done)

# The main run-check target
run-check: post-run-check

TARGETS += run-all-checks pre-run-check post-run-check run-check

all: run-check

.PHONY: default all $(TARGETS)
